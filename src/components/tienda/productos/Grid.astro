---
import type { Product } from "../../../data/products";
import Pagination from "./Pagination.astro";

export interface Props {
	products?: Product[];
	showPagination?: boolean;
}

const { products = [], showPagination = true } = Astro.props;
---

<div id="products-container">
	<!-- Contador de productos integrado -->
	<div
		id="grid-counter"
		class="mb-4 text-sm text-[var(--text-color-soft)]"
	>
		<span id="counter-text">
			Mostrando <span
				id="page-count"
				class="font-semibold text-[var(--text-color)]"
				>0</span
			> de <span
				id="filtered-count"
				class="font-semibold text-[var(--text-color)]"
				>0</span
			> productos
		</span>
	</div>

	<div
		id="products-grid"
		class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-2 lg:grid-cols-4 xl:grid-cols-5 2xl:grid-cols-5 gap-4 lg:gap-5 mb-8"
	>
		<!-- Products will be rendered here by JavaScript -->
	</div>

	<!-- No products message -->
	<div
		id="no-products"
		class="text-center py-12 hidden"
	>
		<div class="mb-4 text-[var(--text-color-soft)]">
			<svg
				class="w-16 h-16 mx-auto"
				fill="none"
				stroke="currentColor"
				viewBox="0 0 24 24"
				stroke-width="2"
				stroke-linecap="round"
				stroke-linejoin="round"
			>
				<path
					stroke="none"
					d="M0 0h24v24H0z"
					fill="none"
				></path>
				<path d="M3 8v3a1 1 0 0 0 1 1h3"></path>
				<path d="M7 8v8"></path>
				<path d="M17 8v3a1 1 0 0 0 1 1h3"></path>
				<path d="M21 8v8"></path>
				<path d="M10 10v4a2 2 0 1 0 4 0v-4a2 2 0 1 0 -4 0"></path>
			</svg>
		</div>
		<h3 class="text-lg font-medium mb-2 text-[var(--accent-color)]">
			No se encontraron productos
		</h3>
		<p class="text-[var(--text-color-soft)]">
			Intenta ajustar los filtros para encontrar lo que buscas.
		</p>
	</div>

	<!-- Loading state -->
	<div
		id="loading"
		class="text-center py-12 hidden"
	>
		<div
			class="animate-spin rounded-full h-12 w-12 border-b-2 border-[var(--text-color-soft)] mx-auto mb-4"
		>
		</div>
		<p class="text-[var(--text-color-soft)]">Cargando productos...</p>
	</div>
</div>

{
	showPagination && (
		<div id="pagination-container">
			<Pagination
				currentPage={1}
				totalPages={1}
				totalProducts={0}
				productsPerPage={12}
				showPageInfo={true}
			/>
		</div>
	)
}

<script>
	// Importaciones y utilidades
	import type { Product } from "../../../data/products";
	import { getAllProducts } from "../../../data/productUtils";
	import { sendTelegramNotification } from "../../../utils/telegram.js";
	import { favoritesStorage } from "../../../utils/secureStorage.js";

	// Extiende el tipo Window para evitar error TS
	declare global {
		interface Window {
			updateFavoritesCount?: (count: number) => void;
		}
	}

	// Estado global de productos y paginación
	let currentProducts: Product[] = [];
	let currentPage = 1;
	const productsPerPage = 25;

	// Función para mezclar un array aleatoriamente (Fisher-Yates)
	function shuffleArray(array: any[]) {
		for (let i = array.length - 1; i > 0; i--) {
			const j = Math.floor(Math.random() * (i + 1));
			[array[i], array[j]] = [array[j], array[i]];
		}
		return array;
	}

	// Sistema global de favoritos (singleton)
	class FavoritesManager {
		private static instance: FavoritesManager;

		private constructor() {}

		static getInstance(): FavoritesManager {
			if (!FavoritesManager.instance) {
				FavoritesManager.instance = new FavoritesManager();
			}
			return FavoritesManager.instance;
		}

		getFavorites(): string[] {
			return favoritesStorage.get();
		}

		saveFavorites(favorites: string[]): boolean {
			return favoritesStorage.set(favorites);
		}

		// Cambia el estado de favorito de un producto y retorna el nuevo estado (sincrónico)
		toggleFavoriteSync(productId: string): boolean {
			// Validar y sanitizar productId
			if (!productId || typeof productId !== 'string') {
				console.warn('Invalid product ID provided');
				return false;
			}

			// Sanitizar productId
			const sanitizedId = productId.replace(/[^a-zA-Z0-9-_]/g, '').substring(0, 50);
			if (!sanitizedId) {
				console.warn('Product ID became empty after sanitization');
				return false;
			}

			const favorites = this.getFavorites();
			const isFavorite = favorites.includes(sanitizedId);
			
			let success: boolean;
			if (isFavorite) {
				success = favoritesStorage.remove(sanitizedId);
			} else {
				success = favoritesStorage.add(sanitizedId);
			}

			if (!success) {
				console.error('Failed to update favorites in secure storage');
				return isFavorite; // Retornar estado anterior si falla
			}

			return !isFavorite; // Retornar nuevo estado
		}

		async notifyTelegram(productName: string, action: "added" | "removed") {
			try {
				await sendTelegramNotification(productName, action);
			} catch (error) {
				console.warn("❌ Failed to send Telegram notification:", error);
			}
		}

		updateHeartIcon(button: HTMLButtonElement, isFavorite: boolean): void {
			const heartIcon = button.querySelector(".heart-icon") as SVGElement;
			if (heartIcon) {
				if (isFavorite) {
					heartIcon.classList.add(
						"fill-[var(--favorite-color)]",
						"text-[var(--favorite-color)]"
					);
					heartIcon.classList.remove(
						"fill-none",
						"text-[var(--text-color-soft)]"
					);
				} else {
					heartIcon.classList.remove(
						"fill-[var(--favorite-color)]",
						"text-[var(--favorite-color)]"
					);
					heartIcon.classList.add("fill-none", "text-[var(--text-color-soft)]");
				}
			}
		}

		updateAllHeartIcons(productId: string, isFavorite: boolean): void {
			const allHeartIcons = document.querySelectorAll(
				`.favorite-btn[data-product-id="${productId}"] .heart-icon`
			) as NodeListOf<SVGElement>;

			allHeartIcons.forEach((icon) => {
				if (isFavorite) {
					icon.classList.add(
						"fill-[var(--favorite-color)]",
						"text-[var(--favorite-color)]"
					);
					icon.classList.remove("fill-none", "text-[var(--text-color-soft)]");
				} else {
					icon.classList.remove(
						"fill-[var(--favorite-color)]",
						"text-[var(--favorite-color)]"
					);
					icon.classList.add("fill-none", "text-[var(--text-color-soft)]");
				}
			});
		}

		initializeButton(button: HTMLButtonElement): void {
			const productId = button.dataset.productId!;
			const favorites = this.getFavorites();
			const isFavorite = favorites.includes(productId);
			this.updateHeartIcon(button, isFavorite);
		}
	}

	const favoritesManager = FavoritesManager.getInstance();

	// Plantillas HTML para las tarjetas de producto (desktop y mobile)
	const templates = {
		// Tarjeta para escritorio
		desktopCard: (product: Product, imageUrl: string) => `
		<div class="hidden lg:block rounded-lg shadow transition-shadow overflow-hidden hover:shadow-xl bg-[var(--cajas)]">
			<div class="relative">
				<a href="/producto/${product.slug}" class="block">
					<div class="aspect-square overflow-hidden">
						<img
							src="${imageUrl}"
							alt="${product.name}"
							class="w-full h-full object-cover hover:scale-105 transition-transform duration-300"
							loading="lazy"
						/>
					</div>
				</a>

				<div class="absolute top-3 right-3">
					<button
						class="favorite-btn relative w-8 h-8 transition-all duration-200 flex items-center justify-center group bg-white rounded-full p-2 shadow-lg"
						data-product-id="${product.id}"
						data-product-name="${product.name}"
						aria-label="${product.name} - Agregar a favoritos"
					>
						<svg
							class="heart-icon w-5 h-5 text-[var(--text-color-soft)] transition-all duration-200"
							fill="none"
							stroke="currentColor"
							viewBox="0 0 24 24"
						>
							<path
								stroke-linecap="round"
								stroke-linejoin="round"
								stroke-width="2"
								d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"
							/>
						</svg>
					</button>
				</div>
			</div>
			<div class="p-4">
				<div class="mb-2">
				</div>
				<h3 class="font-semibold text-[var(--accent-color)] mb-2 line-clamp-2">
					<a href="/producto/${product.slug}" class="hover:text-[var(--accent-color)] transition-colors">
						${product.name}
					</a>
				</h3>
				<p class="text-sm text-[var(--text-color)] mb-3 line-clamp-2">
					${product.shortDescription}
				</p>
				<div class="flex items-center justify-between">
					<a
						href="/producto/${product.slug}"
						class="text-sm font-medium transition-colors text-[var(--accent-color)] hover:text-[var(--vinculo)]"
					>
						Ver detalles →
					</a>
				</div>
			</div>
		</div>
	`,

		// Tarjeta para móvil
		mobileCard: (product: Product, imageUrl: string) => `
		<div class="flex lg:hidden h-[100px] bg-[var(--cajas)] rounded-lg overflow-hidden">
			<div class="w-[100px] h-[100px] flex-shrink-0 relative">
				<img
					src="${imageUrl}"
					alt="${product.name}"
					class="w-full h-full object-cover"
					loading="lazy"
				/>
				<!-- Favorite button positioned at top-right of image -->
				<div class="absolute top-2 right-2 z-20">
					<button
						class="favorite-btn w-7 h-7 transition-all duration-200 flex items-center justify-center group bg-white rounded-full p-2 shadow-lg"
						data-product-id="${product.id}"
						data-product-name="${product.name}"
						aria-label="${product.name} - Agregar a favoritos"
					>
						<svg
							class="heart-icon w-3 h-3 text-[var(--text-color-soft)] transition-all duration-200"
							fill="none"
							stroke="currentColor"
							viewBox="0 0 24 24"
						>
							<path
								stroke-linecap="round"
								stroke-linejoin="round"
								stroke-width="2"
								d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"
							/>
						</svg>
					</button>
				</div>
				<!-- Optional: subtle dark overlay for better contrast -->
				<div class="absolute inset-0 pointer-events-none bg-gradient-to-t from-black/10 via-black/0 to-black/0"></div>
			</div>
			<div class="flex-1 p-2 flex flex-col justify-between">
				<div>
					<h3 class="text-sm font-medium text-[var(--text-color)] line-clamp-1">
						<a href="/producto/${product.slug}" class="hover:text-[var(--accent-color)] transition-colors">
							${product.name}
						</a>
					</h3>
					<p class="text-xs text-[var(--text-color-soft)] line-clamp-2 mt-1">
						${product.shortDescription?.slice(0, 90)}...
					</p>
				</div>
				<div class="flex items-center justify-between mt-1">
					<a
						href="/producto/${product.slug}"
						class="text-xs text-[var(--accent-color)] hover:text-[var(--vinculo)] transition-colors"
					>
						leer más →
					</a>
				</div>
			</div>
		</div>
	`,
	};

	// Crea un elemento de tarjeta de producto a partir de los datos
	function createProductCard(product: Product) {
		const card = document.createElement("div");
		card.className = "product-card";

		// Obtiene la imagen principal o un placeholder
		let imageUrl =
			"https://via.placeholder.com/400x400/374151/FFFFFF?text=Sin+Imagen";
		if (product.images && product.images.length > 0) {
			const mainImage = product.images[0];
			if (typeof mainImage === "string") {
				imageUrl = mainImage;
			} else if (
				mainImage &&
				typeof mainImage === "object" &&
				"src" in mainImage
			) {
				imageUrl = mainImage.src;
			}
		}

		card.innerHTML =
			templates.desktopCard(product, imageUrl) +
			templates.mobileCard(product, imageUrl);
		return card;
	}

	// Actualiza el contador de productos mostrados y filtrados
	function updateCounter(pageProducts: Product[], totalFiltered: number) {
		const pageCountElement = document.getElementById("page-count");
		const filteredCountElement = document.getElementById("filtered-count");
		const counterText = document.getElementById("counter-text");

		if (pageCountElement && filteredCountElement && counterText) {
			const pageCount = pageProducts.length;

			pageCountElement.textContent = pageCount.toString();
			filteredCountElement.textContent = totalFiltered.toString();

			// Actualiza el texto del contador
			counterText.innerHTML = `Mostrando <span id="page-count" class="font-semibold text-[var(--text-color)]">${pageCount}</span> de <span id="filtered-count" class="font-semibold text-[var(--text-color)]">${totalFiltered}</span> productos`;
		}
	}

	// Actualiza el componente de paginación mediante un evento
	function updatePaginationComponent(
		totalProducts: number,
		currentPageNum: number
	) {
		const totalPages = Math.ceil(totalProducts / productsPerPage);

		// Dispara un evento para actualizar la paginación
		window.dispatchEvent(
			new CustomEvent("paginationUpdate", {
				detail: {
					currentPage: currentPageNum,
					totalPages: totalPages,
					totalProducts: totalProducts,
					productsPerPage: productsPerPage,
				},
			})
		);
	}

	// Renderiza los productos en el grid según la página
	function renderProducts(products: Product[], page: number = 1) {
		const grid = document.getElementById("products-grid");
		const noProducts = document.getElementById("no-products");
		const loading = document.getElementById("loading");

		if (!grid || !noProducts || !loading) {
			return;
		}

		if (page === 1) {
			loading.classList.remove("hidden");
			grid.classList.add("hidden");
			noProducts.classList.add("hidden");
		}

		setTimeout(() => {
			const startIndex = (page - 1) * productsPerPage;
			const endIndex = startIndex + productsPerPage;
			const pageProducts = products.slice(startIndex, endIndex);

			if (pageProducts.length === 0) {
				grid.classList.add("hidden");
				noProducts.classList.remove("hidden");
				updateCounter([], products.length);
			} else {
				grid.innerHTML = "";
				pageProducts.forEach((product) => {
					const productCard = createProductCard(product);
					grid.appendChild(productCard);
				});

				grid.classList.remove("hidden");
				noProducts.classList.add("hidden");
				updateCounter(pageProducts, products.length);
			}

			loading.classList.add("hidden");
			updatePaginationComponent(products.length, page);

			// Inicializa los botones de favoritos después de renderizar
			setTimeout(() => {
				initializeFavoriteButtons();
			}, 100);
		}, 300);
	}

	// Maneja el click en el botón de favorito
	async function handleFavoriteClick(e: Event) {
		e.preventDefault();
		e.stopPropagation();

		const button = e.currentTarget as HTMLButtonElement;
		const productId = button.dataset.productId!;
		const productName = button.dataset.productName!;

		if (button.disabled) return;
		button.disabled = true;

		const newIsFavorite = favoritesManager.toggleFavoriteSync(productId);
		favoritesManager.updateAllHeartIcons(productId, newIsFavorite);

		window.dispatchEvent(
			new CustomEvent("favoritesChanged", {
				detail: { productId, isFavorite: newIsFavorite, productName },
			})
		);

		if (window.updateFavoritesCount) {
			const favorites = favoritesManager.getFavorites();
			window.updateFavoritesCount(favorites.length);
		}

		favoritesManager
			.notifyTelegram(productName, newIsFavorite ? "added" : "removed")
			.finally(() => {
				button.disabled = false;
			});
	}

	function initializeFavoriteButtons() {
		const favoriteButtons = document.querySelectorAll(
			".favorite-btn"
		) as NodeListOf<HTMLButtonElement>;
		favoriteButtons.forEach((button) => {
			favoritesManager.initializeButton(button);
			const newButton = button.cloneNode(true) as HTMLButtonElement;
			button.parentNode?.replaceChild(newButton, button);
			newButton.addEventListener("click", handleFavoriteClick);
		});
	}

	function initializeGrid() {
		window.addEventListener("pageChanged", (e: any) => {
			const { page } = e.detail;
			currentPage = page;
			renderProducts(currentProducts, page);
		});
		window.addEventListener("productsFiltered", (e: any) => {
			currentProducts = e.detail.products;
			currentPage = 1;
			renderProducts(currentProducts, 1);
		});
		window.addEventListener("favoritesChanged", () => {
			setTimeout(initializeFavoriteButtons, 100);
		});
		if (currentProducts.length === 0) {
			currentProducts = shuffleArray(getAllProducts());
			renderProducts(currentProducts, 1);
		}
	}
	document.addEventListener("DOMContentLoaded", initializeGrid);
	document.addEventListener("astro:page-load", initializeGrid);
</script>
