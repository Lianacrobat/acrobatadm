---
import { testimonios } from "./testimonios.ts";
const hasTestimonios = Array.isArray(testimonios) && testimonios.length > 0;
---

<div class="w-full">
	<h3 class="text-base font-bold mb-4">Testimonios:</h3>
</div>

{
	hasTestimonios ? (
		<div class="flex flex-col items-center w-full">
			<div class="flex items-center justify-center gap-2 sm:gap-4 md:gap-6 w-full ">
				<button
					class="hidden md:flex text-2xl w-10 h-10  cursor-pointer transition-all duration-150 z-10 items-center justify-center group"
					aria-label="Anterior testimonio"
					id="carousel-prev"
					tabindex="0"
					type="button"
				>
					<svg
						width="24"
						height="24"
						viewBox="0 0 24 24"
						class="w-7 h-7 transition-colors duration-150 group-hover:accent-arrow scale-x-[-1]"
					>
						<use href={`${import.meta.env.BASE_URL}icons/sprite.svg#arrow-right`} />
					</svg>
				</button>
				<div class="relative flex-1 flex justify-center overflow-hidden bg-[var(--cajas)] rounded-2xl">
					<div
						id="carousel-content"
						class="w-full flex flex-col items-center"
					>
						{testimonios.map((t, idx) => (
							<div
								class={`carousel-item ${idx === 0 ? "opacity-100 scale-100 pointer-events-auto" : "opacity-0 scale-95 pointer-events-none"} absolute left-0 right-0 top-0 mx-auto flex flex-col items-center justify-between w-full h-[280px] sm:h-[320px] md:h-[380px] rounded-2xl p-3 sm:p-4 md:p-8 bg-cajas z-[1]`}
								data-index={idx}
								aria-hidden={idx !== 0}
								role="group"
								tabindex={idx === 0 ? 0 : -1}
							>
								<span class="inline-flex items-center justify-center rounded-full mb-2 sm:mb-3 bg-gradient-to-tr from-amber-400 to-pink-600 p-[2px]">
									<span class="bg-[var(--cajas)] rounded-full block p-[2.5px] sm:p-[3.5px] md:p-[5px]">
										<img
											class="w-14 h-14 sm:w-16 sm:h-16 md:w-20 md:h-20 rounded-full object-cover"
											src={t.foto.replace("@public", "")}
											alt={t.nombre}
											loading="lazy"
										/>
									</span>
								</span>
								<div class="flex items-center justify-center gap-2 mb-1">
									<span class="font-bold text-base sm:text-lg md:text-2xl text-center text-[var(--text-color)]">
										{t.nombre}
									</span>
									{t.verificado && (
										<svg
											width="16"
											height="16"
											viewBox="0 0 24 24"
										>
											<use href={`${import.meta.env.BASE_URL}icons/sprite.svg#verificado`} />
										</svg>
									)}
								</div>
								{t.instagram && (
									<a
										href={`https://instagram.com/${t.instagram}`}
										target="_blank"
										rel="noopener noreferrer"
										class="block text-center text-[var(--accent-color)] font-medium mb-1 text-xs sm:text-sm md:text-lg hover:underline"
									>
										@{t.instagram}
									</a>
								)}
								<div class="text-center text-xs sm:text-sm md:text-base mb-2 sm:mb-4 text-[var(--text-color-soft)]">
									{t.cargo} {t.empresa && <> en {t.empresa}</>}
								</div>
								<div class="flex-1 flex items-center justify-center w-full">
									<div class="text-xs sm:text-sm md:text-lg text-center italic text-[var(--text-color)]">
										“{t.texto}”
									</div>
								</div>
								<div class="flex justify-between items-center w-full mt-2 sm:mt-4 text-xs sm:text-sm text-[var(--text-color-soft)]">
									<span>{t.pais}</span>
									<span>
										{t.fecha
											? new Date(t.fecha).toLocaleString("default", {
													month: "short",
													year: "numeric",
												})
											: ""}
									</span>
								</div>
							</div>
						))}
					</div>
				</div>
				<button
					class="hidden md:flex text-2xl w-10 h-10 cursor-pointer transition-all duration-150 z-10 items-center justify-center group"
					aria-label="Siguiente testimonio"
					id="carousel-next"
					tabindex="0"
					type="button"
				>
					<svg
						width="24"
						height="24"
						viewBox="0 0 24 24"
						class="w-7 h-7 transition-colors duration-150 group-hover:accent-arrow"
					>
						<use href={`${import.meta.env.BASE_URL}icons/sprite.svg#arrow-right`} />
					</svg>
				</button>
			</div>
			{testimonios.length > 1 && (
				<div
					class="flex justify-center mt-4 sm:mt-3 md:mt-5"
					id="carousel-indicators"
				>
					{testimonios.map((_, idx) => (
						<span
							class={`w-2 h-2 rounded-full mx-1  cursor-pointer ${idx === 0 ? "dot-active" : "dot-inactive"}`}
							data-index={idx}
							tabindex="0"
							role="button"
							aria-label={`Ir al testimonio ${idx + 1}`}
						/>
					))}
				</div>
			)}
		</div>
	) : (
		<div class="flex items-center justify-center min-h-40 text-[var(--text-color-soft)]">
			No hay testimonios disponibles.
		</div>
	)
}

<script>
	const config = {
		autoPlay: true,
		autoPlayInterval: 5500,
		pauseOnHover: true,
		swipeThreshold: 50,
		swipeVelocityThreshold: 0.5,
		// Nuevas configuraciones
		preloadImages: true,
		reducedMotion: typeof window !== 'undefined' ? window.matchMedia('(prefers-reduced-motion: reduce)').matches : false,
		infiniteLoop: true,
		visibilityThreshold: 0.5 // Para Intersection Observer
	};

	function initCarousel() {
		const content = document.getElementById("carousel-content");
		const items = Array.from(document.querySelectorAll(".carousel-item"));
		const dots = Array.from(
			document.querySelectorAll("#carousel-indicators > span")
		);
		const prevBtn = document.getElementById("carousel-prev");
		const nextBtn = document.getElementById("carousel-next");

		if (!content || items.length < 2) {
			if (!content) console.warn("Carousel: No content found.");
			return;
		}

		// Estado centralizado del carrusel
		const carouselState = {
			currentIndex: 0,
			isPlaying: false,
			isTransitioning: false,
			isVisible: true,
			touchData: {
				startX: 0,
				endX: 0,
				startTime: 0,
				isOnLink: false
			}
		};

		const total = items.length;
		let autoPlayTimer: ReturnType<typeof setInterval> | null = null;
		let intersectionObserver: IntersectionObserver | null = null;
		let eventListeners: Array<{ element: Element | Document, event: string, handler: EventListener }> = [];

		// Función para agregar event listeners con cleanup automático
		function addEventListenerWithCleanup(element: Element | Document, event: string, handler: EventListener, options?: AddEventListenerOptions) {
			element.addEventListener(event, handler, options);
			eventListeners.push({ element, event, handler });
		}

		// Animaciones optimizadas con soporte para reduced motion
		function showSlide(idx: number, animate = true) {
			idx = ((idx % total) + total) % total;
			if (idx === carouselState.currentIndex || carouselState.isTransitioning) return;
			
			carouselState.isTransitioning = true;
			carouselState.currentIndex = idx;

			const shouldAnimate = animate && !config.reducedMotion;

			window.requestAnimationFrame(() => {
				for (let i = 0; i < total; i++) {
					const el = items[i] as HTMLElement;
					const isActive = i === idx;
					
					el.style.transition = shouldAnimate
						? "opacity 0.35s ease-in-out, transform 0.35s ease-in-out"
						: "none";
					
					el.classList.toggle("opacity-100", isActive);
					el.classList.toggle("scale-100", isActive);
					el.classList.toggle("pointer-events-auto", isActive);
					el.classList.toggle("opacity-0", !isActive);
					el.classList.toggle("scale-95", !isActive);
					el.classList.toggle("pointer-events-none", !isActive);
					el.setAttribute("aria-hidden", isActive ? "false" : "true");
					el.setAttribute("tabindex", isActive ? "0" : "-1");
				}
				
				for (let i = 0; i < dots.length; i++) {
					dots[i].classList.toggle("dot-active", i === idx);
					dots[i].classList.toggle("dot-inactive", i !== idx);
				}
				
				// Reset transition flag después de la animación
				setTimeout(() => {
					carouselState.isTransitioning = false;
				}, shouldAnimate ? 350 : 0);
			});
		}

		// Mejor throttle: usa timestamp para evitar bloqueos por setTimeout
		function throttle<T extends (...args: any[]) => any>(fn: T, limit: number) {
			let lastCall = 0;
			return (...args: Parameters<T>) => {
				const now = Date.now();
				if (now - lastCall >= limit) {
					lastCall = now;
					fn(...args);
				}
			};
		}

		// Gestión mejorada del autoplay con estado
		function startAutoPlay() {
			if (config.autoPlay && total > 1 && !autoPlayTimer && carouselState.isVisible) {
				carouselState.isPlaying = true;
				autoPlayTimer = setInterval(() => {
					if (carouselState.isVisible && !carouselState.isTransitioning) {
						showSlide(carouselState.currentIndex + 1);
					}
				}, config.autoPlayInterval);
			}
		}

		function stopAutoPlay() {
			if (autoPlayTimer) {
				clearInterval(autoPlayTimer);
				autoPlayTimer = null;
				carouselState.isPlaying = false;
			}
		}

		// Intersection Observer para pausar cuando no es visible
		function setupIntersectionObserver() {
			if ('IntersectionObserver' in window) {
				intersectionObserver = new IntersectionObserver(
					(entries) => {
						entries.forEach(entry => {
							carouselState.isVisible = entry.isIntersecting;
							if (entry.isIntersecting) {
								startAutoPlay();
							} else {
								stopAutoPlay();
							}
						});
					},
					{ threshold: config.visibilityThreshold }
				);
				if (content) {
					intersectionObserver.observe(content);
				}
			}
		}

		// Función de limpieza para evitar memory leaks
		function cleanup() {
			stopAutoPlay();
			intersectionObserver?.disconnect();
			
			// Remover todos los event listeners
			eventListeners.forEach(({ element, event, handler }) => {
				element.removeEventListener(event, handler);
			});
			eventListeners = [];
		}

		const prev = throttle(() => showSlide(carouselState.currentIndex - 1), 300);
		const next = throttle(() => showSlide(carouselState.currentIndex + 1), 300);

		if (prevBtn) addEventListenerWithCleanup(prevBtn, "click", prev);
		if (nextBtn) addEventListenerWithCleanup(nextBtn, "click", next);

		// Dots con cleanup automático
		dots.forEach((dot, i) => {
			addEventListenerWithCleanup(dot, "click", (e: Event) => {
				const target = e.target as HTMLElement;
				if (target?.closest("a")) return;
				showSlide(i);
			});
			
			addEventListenerWithCleanup(dot, "keydown", (e: Event) => {
				const keyboardEvent = e as KeyboardEvent;
				if (keyboardEvent.key === "Enter" || keyboardEvent.key === " ") {
					e.preventDefault();
					showSlide(i);
				}
			});
		});

		// Navegación por teclado con cleanup
		addEventListenerWithCleanup(document, "keydown", (e: Event) => {
			const keyboardEvent = e as KeyboardEvent;
			const target = e.target as HTMLElement;
			if (
				target &&
				(target.tagName === "INPUT" || target.tagName === "TEXTAREA")
			)
				return;
			if (keyboardEvent.key === "ArrowLeft") prev();
			if (keyboardEvent.key === "ArrowRight") next();
		});

		// Swipe optimizado
		const swipe = throttle((dir: "left" | "right") => {
			if (dir === "left") {
				showSlide(carouselState.currentIndex + 1);
			} else {
				showSlide(carouselState.currentIndex - 1);
			}
		}, 300);

		// --- EFECTO DE SWIPE MEJORADO: la tarjeta se mueve en la dirección correcta al arrastrar --- border
		let lastDiff = 0;

		addEventListenerWithCleanup(
			content,
			"touchstart",
			(e: Event) => {
				const touchEvent = e as TouchEvent;
				const target = e.target as HTMLElement;
				carouselState.touchData.isOnLink = !!target?.closest("a");
				carouselState.touchData.startX = touchEvent.touches[0].clientX;
				carouselState.touchData.startTime = performance.now();
				lastDiff = 0;
				stopAutoPlay();
			},
			{ passive: true }
		);

		addEventListenerWithCleanup(
			content,
			"touchmove",
			(e: Event) => {
				const touchEvent = e as TouchEvent;
				carouselState.touchData.endX = touchEvent.touches[0].clientX;
				const diff = carouselState.touchData.endX - carouselState.touchData.startX;
				lastDiff = diff;
				const item = items[carouselState.currentIndex] as HTMLElement;
				// Limitar el movimiento y aplicar easing
				const limitedDiff = Math.max(Math.min(diff * 0.4, 60), -60);
				if (!config.reducedMotion) {
					item.style.transform = `translateX(${limitedDiff}px) scale(1)`;
				}
			},
			{ passive: true }
		);

		addEventListenerWithCleanup(
			content,
			"touchend",
			() => {
				const diff = lastDiff;
				const duration = performance.now() - carouselState.touchData.startTime;
				const velocity = Math.abs(diff) / (duration || 1);
				const item = items[carouselState.currentIndex] as HTMLElement;
				
				// Reset transform
				if (!config.reducedMotion) {
					item.style.transform = `scale(1)`;
				}

				if (
					Math.abs(diff) > config.swipeThreshold ||
					velocity > config.swipeVelocityThreshold
				) {
					if (diff < 0) {
						swipe("left");
					} else if (diff > 0) {
						swipe("right");
					}
				} else if (carouselState.touchData.isOnLink) {
					// Reset touch data
					carouselState.touchData = { startX: 0, endX: 0, startTime: 0, isOnLink: false };
					return;
				}
				
				startAutoPlay();
				// Reset touch data
				carouselState.touchData = { startX: 0, endX: 0, startTime: 0, isOnLink: false };
				lastDiff = 0;
			},
			{ passive: true }
		);
		// --- FIN DEL EFECTO DE SWIPE ---

		// Hover events con cleanup
		if (config.pauseOnHover) {
			addEventListenerWithCleanup(content, "mouseenter", stopAutoPlay);
			addEventListenerWithCleanup(content, "mouseleave", startAutoPlay);
		}

		// Preload de imágenes si está habilitado
		if (config.preloadImages) {
			items.forEach(item => {
				const img = item.querySelector('img');
				if (img && !img.complete) {
					img.loading = 'eager';
				}
			});
		}

		// Setup y arranque inicial
		setupIntersectionObserver();
		showSlide(0, false);
		startAutoPlay();

		// Cleanup al descargar la página
		if (typeof window !== 'undefined') {
			window.addEventListener("beforeunload", cleanup);
			eventListeners.push({ element: document, event: "beforeunload", handler: cleanup });
		}
		
		// Retornar función de cleanup para uso manual si es necesario
		return cleanup;
	}

	if (typeof window !== "undefined") {
		setTimeout(initCarousel, 1); // Espera a que el DOM esté listo
	}
	initCarousel();
</script>

<style>
	.dot-active {
		background-color: var(--accent-color);
		transform: scale(1.2);
	}
	.dot-inactive {
		background-color: var(--cajas);
		transform: scale(1);
	}

	.carousel-item.opacity-100 {
		opacity: 1;
		transform: scale(1);
		pointer-events: auto;
		position: relative;
	}
	.group svg {
		color: var(--text-color-soft);
	}
	.group:hover svg,
	.group:focus svg {
		color: var(--accent-color);
	}
	@media (min-width: 1024px) {
		.carousel-item {
			max-width: 700px;
			margin-left: auto;
			margin-right: auto;
		}
	}
	@media (max-width: 1023px) {
		.carousel-item {
			width: 100%;
			max-width: 100%;
			margin-left: 0;
			margin-right: 0;
		}
	}
</style>
